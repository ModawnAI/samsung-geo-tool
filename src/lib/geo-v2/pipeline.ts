/**
 * GEO v2 Pipeline Orchestrator
 * Manages the 7-stage content generation pipeline with parallel execution
 */

import type {
  PipelineStage,
  PipelineProgress,
  GEOv2GenerateResponse,
  GEOv2Score,
  USPExtractionResult,
  FAQResult,
  CaseStudyResult,
  GroundingMetadata,
  GroundingQualityScore,
  GroundingSource,
  UniqueSellingPoint,
} from '@/types/geo-v2'
import { STAGE_PROGRESS_MAP } from '@/types/geo-v2'
import { extractUSPs } from './usp-extraction'
import {
  calculateGroundingQualityScore,
  aggregateGroundingMetadata,
} from './grounding-scorer'
import { checkForFabrications, sanitizeContent } from './anti-fabrication'

export interface PipelineInput {
  productName: string
  youtubeUrl: string
  srtContent: string
  existingDescription?: string
  keywords: string[]
  language: 'ko' | 'en'
  groundingSignals: Array<{
    term: string
    score: number
    source?: string
    recency?: string
  }>
  groundingSources?: GroundingSource[]
  onProgress?: (progress: PipelineProgress) => void
}

export interface PipelineContext {
  input: PipelineInput
  uspResult?: USPExtractionResult
  description?: {
    preview: string
    full: string
    vanityLinks: string[]
  }
  chapters?: {
    timestamps: string
    autoGenerated: boolean
  }
  faq?: FAQResult
  stepByStep?: {
    steps: string[]
    isTutorialContent: boolean
  }
  caseStudies?: CaseStudyResult
  keywords?: {
    product: string[]
    generic: string[]
    densityScore: number
  }
  hashtags?: string[]
  groundingMetadata?: GroundingMetadata
  stageGroundingData: Array<{
    stage: string
    sources: GroundingSource[]
    searchQueries?: string[]
  }>
  errors: Array<{
    stage: PipelineStage
    error: string
    recoverable: boolean
  }>
}

type StageExecutor = (ctx: PipelineContext) => Promise<void>

/**
 * Main pipeline orchestrator
 */
export class GEOv2Pipeline {
  private progressCallback?: (progress: PipelineProgress) => void
  private startTime: number = 0

  constructor(onProgress?: (progress: PipelineProgress) => void) {
    this.progressCallback = onProgress
  }

  /**
   * Execute the complete v2 pipeline
   */
  async execute(input: PipelineInput): Promise<GEOv2GenerateResponse> {
    this.startTime = Date.now()
    this.progressCallback = input.onProgress

    const context: PipelineContext = {
      input,
      stageGroundingData: [],
      errors: [],
    }

    try {
      // Stage 1: Description (sequential - foundation)
      await this.executeStage('description', context, this.executeDescriptionStage)

      // Stage 1.5: USP Extraction (sequential - depends on description grounding)
      await this.executeStage('usp_extraction', context, this.executeUSPExtractionStage)

      // Parallel Batch 1: Chapters + FAQ
      await this.executeParallelBatch([
        { stage: 'chapters' as PipelineStage, executor: this.executeChaptersStage },
        { stage: 'faq' as PipelineStage, executor: this.executeFAQStage },
      ], context)

      // Parallel Batch 2: Step-by-Step + Case Studies
      await this.executeParallelBatch([
        { stage: 'step_by_step' as PipelineStage, executor: this.executeStepByStepStage },
        { stage: 'case_studies' as PipelineStage, executor: this.executeCaseStudiesStage },
      ], context)

      // Stage 6: Keywords (sequential)
      await this.executeStage('keywords', context, this.executeKeywordsStage)

      // Stage 7: Grounding Aggregation
      await this.executeStage('grounding_aggregation', context, this.executeGroundingAggregationStage)

      // Calculate final score
      const finalScore = this.calculateFinalScore(context)

      // Build response
      return this.buildResponse(context, finalScore)
    } catch (error) {
      console.error('[Pipeline] Fatal error:', error)
      throw error
    }
  }

  /**
   * Execute a single pipeline stage
   */
  private async executeStage(
    stage: PipelineStage,
    context: PipelineContext,
    executor: StageExecutor
  ): Promise<void> {
    const stageInfo = STAGE_PROGRESS_MAP[stage]
    const startTime = new Date().toISOString()

    this.reportProgress({
      stage,
      percentage: stageInfo.percentage,
      message: stageInfo.message,
      startedAt: startTime,
    })

    try {
      await executor.call(this, context)

      this.reportProgress({
        stage,
        percentage: stageInfo.percentage,
        message: `${stageInfo.message} - Complete`,
        startedAt: startTime,
        completedAt: new Date().toISOString(),
      })
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error)
      console.error(`[Pipeline] Stage ${stage} failed:`, errorMsg)

      context.errors.push({
        stage,
        error: errorMsg,
        recoverable: this.isRecoverableError(stage),
      })

      // Continue pipeline for recoverable errors
      if (!this.isRecoverableError(stage)) {
        throw error
      }
    }
  }

  /**
   * Execute multiple stages in parallel
   */
  private async executeParallelBatch(
    stages: Array<{ stage: PipelineStage; executor: StageExecutor }>,
    context: PipelineContext
  ): Promise<void> {
    const stageNames = stages.map(s => s.stage).join(', ')
    console.log(`[Pipeline] Starting parallel batch: ${stageNames}`)

    await Promise.all(
      stages.map(({ stage, executor }) =>
        this.executeStage(stage, context, executor)
      )
    )
  }

  /**
   * Stage 1: Description Generation
   */
  private async executeDescriptionStage(context: PipelineContext): Promise<void> {
    // This will be implemented by the generate API route
    // For now, create placeholder that will be filled by integration
    console.log('[Pipeline] Description stage - delegating to Gemini')
    // The actual implementation connects to existing description generation logic
  }

  /**
   * Stage 1.5: USP Extraction
   */
  private async executeUSPExtractionStage(context: PipelineContext): Promise<void> {
    const { input } = context

    const uspResult = await extractUSPs({
      productName: input.productName,
      srtContent: input.srtContent,
      keywords: input.keywords,
      groundingSignals: input.groundingSignals,
      groundingSources: input.groundingSources,
    })

    context.uspResult = uspResult

    // Add grounding data from USP extraction
    if (uspResult.usps.length > 0) {
      const uspSources: GroundingSource[] = []
      const uspQueries: string[] = []

      for (const usp of uspResult.usps) {
        if (usp.evidence.sources) {
          for (const source of usp.evidence.sources) {
            if (source.startsWith('http')) {
              uspSources.push({
                uri: source,
                title: 'USP Evidence',
                usedIn: ['usp_extraction'],
                tier: 2,
              })
            }
          }
        }
        if (usp.evidence.searchQueries) {
          uspQueries.push(...usp.evidence.searchQueries)
        }
      }

      context.stageGroundingData.push({
        stage: 'usp_extraction',
        sources: uspSources,
        searchQueries: uspQueries,
      })
    }
  }

  /**
   * Stage 2: Chapters Generation
   */
  private async executeChaptersStage(context: PipelineContext): Promise<void> {
    // Chapters don't require grounding - structure-based
    console.log('[Pipeline] Chapters stage - generating from transcript structure')
    // Implementation delegated to generate route
  }

  /**
   * Stage 3: FAQ Generation
   */
  private async executeFAQStage(context: PipelineContext): Promise<void> {
    // FAQ requires grounding and USP connection
    console.log('[Pipeline] FAQ stage - generating with USP connection')
    // Implementation delegated to generate route
  }

  /**
   * Stage 4: Step-by-Step Guide
   */
  private async executeStepByStepStage(context: PipelineContext): Promise<void> {
    // Step-by-step doesn't require grounding - instruction-based
    console.log('[Pipeline] Step-by-step stage - generating tutorial content')
    // Implementation delegated to generate route
  }

  /**
   * Stage 5: Case Studies
   */
  private async executeCaseStudiesStage(context: PipelineContext): Promise<void> {
    // Case studies require grounding and are USP-driven
    console.log('[Pipeline] Case studies stage - generating with evidence')
    // Implementation delegated to generate route
  }

  /**
   * Stage 6: Keywords Extraction
   */
  private async executeKeywordsStage(context: PipelineContext): Promise<void> {
    // Keywords don't require grounding - extraction-based
    console.log('[Pipeline] Keywords stage - extracting product and generic keywords')
    // Implementation delegated to generate route
  }

  /**
   * Stage 7: Grounding Aggregation
   */
  private async executeGroundingAggregationStage(context: PipelineContext): Promise<void> {
    console.log('[Pipeline] Grounding aggregation stage')

    // Aggregate all grounding metadata from stages
    context.groundingMetadata = aggregateGroundingMetadata(context.stageGroundingData)
  }

  /**
   * Calculate final GEO v2 score
   */
  private calculateFinalScore(context: PipelineContext): GEOv2Score {
    const usps = context.uspResult?.usps || []
    const sources = context.groundingMetadata?.sources || []

    // Calculate grounding quality score
    const groundingQuality = calculateGroundingQualityScore({
      sources,
      usps,
      totalSections: 7, // 7 stages
      sectionsWithGrounding: context.stageGroundingData.filter(s => s.sources.length > 0).length,
      contentLength: 5000, // Estimated - would be calculated from actual content
      citedContentLength: sources.length * 200, // Rough estimate per source
    })

    // Placeholder scores - these will be calculated from actual content
    const keywordDensity = 12 // /15
    const aiExposure = 20 // /25
    const questionPatterns = 16 // /20
    const sentenceStructure = 12 // /15
    const lengthCompliance = 12 // /15

    const total =
      keywordDensity +
      aiExposure +
      questionPatterns +
      sentenceStructure +
      lengthCompliance +
      groundingQuality.total

    return {
      keywordDensity,
      aiExposure,
      questionPatterns,
      sentenceStructure,
      lengthCompliance,
      groundingQuality,
      total: Math.round(total * 100) / 100,
    }
  }

  /**
   * Build final response object
   */
  private buildResponse(context: PipelineContext, finalScore: GEOv2Score): GEOv2GenerateResponse {
    // Validate and sanitize content for fabrications
    let description = context.description || {
      preview: '',
      full: '',
      vanityLinks: [],
    }

    if (description.full) {
      const sanitized = sanitizeContent(description.full)
      if (sanitized.wasModified) {
        console.log('[Pipeline] Content sanitized:', sanitized.modifications.length, 'modifications')
        description = {
          ...description,
          full: sanitized.sanitized,
        }
      }
    }

    return {
      description,
      uspResult: context.uspResult || {
        usps: [],
        competitiveContext: '',
        extractionMethod: 'generative',
        groundingQuality: 0,
      },
      chapters: context.chapters || {
        timestamps: '',
        autoGenerated: true,
      },
      faq: context.faq || {
        faqs: [],
        queryPatternOptimization: true,
      },
      stepByStep: context.stepByStep,
      caseStudies: context.caseStudies,
      keywords: context.keywords || {
        product: [],
        generic: [],
        densityScore: 0,
      },
      hashtags: context.hashtags || [],
      finalScore,
      groundingMetadata: context.groundingMetadata,
      progress: this.getProgressHistory(),
    }
  }

  /**
   * Report progress to callback
   */
  private reportProgress(progress: PipelineProgress): void {
    console.log(`[Pipeline] ${progress.percentage}% - ${progress.message}`)
    this.progressCallback?.(progress)
  }

  /**
   * Check if error is recoverable
   */
  private isRecoverableError(stage: PipelineStage): boolean {
    // Description and USP extraction are critical - not recoverable
    if (stage === 'description' || stage === 'usp_extraction') {
      return false
    }
    // Other stages can continue with defaults
    return true
  }

  /**
   * Get progress history (placeholder)
   */
  private getProgressHistory(): PipelineProgress[] {
    // Would track actual progress history
    return []
  }
}

/**
 * Execute the v2 pipeline
 * Main entry point for API routes
 */
export async function executeGEOv2Pipeline(
  input: PipelineInput
): Promise<GEOv2GenerateResponse> {
  const pipeline = new GEOv2Pipeline(input.onProgress)
  return pipeline.execute(input)
}

/**
 * Pipeline configuration for different modes
 */
export const PIPELINE_CONFIGS = {
  full: {
    stages: ['description', 'usp_extraction', 'chapters', 'faq', 'step_by_step', 'case_studies', 'keywords', 'grounding_aggregation'],
    parallel: true,
  },
  quick: {
    stages: ['description', 'usp_extraction', 'faq', 'keywords'],
    parallel: false,
  },
  grounded: {
    stages: ['description', 'usp_extraction', 'faq', 'case_studies', 'grounding_aggregation'],
    parallel: true,
  },
} as const

export type PipelineConfig = keyof typeof PIPELINE_CONFIGS
