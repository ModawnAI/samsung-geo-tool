/**
 * GEO v2 Generation API Route
 * 7-Stage Pipeline with USP-Centric Architecture
 */

import { NextRequest, NextResponse } from 'next/server'
import { GoogleGenAI } from '@google/genai'
import { multiQuerySearch, getSectionContext } from '@/lib/rag/search'
import { isPineconeConfigured } from '@/lib/pinecone/client'
import {
  executeGEOv2Pipeline,
  extractUSPs,
  checkForFabrications,
  sanitizeContent,
  calculateGroundingQualityScore,
  getSourceTier,
  extractGroundingSources,
  aggregateGroundingMetadata,
  getAntiFabricationPrompt,
  PIPELINE_CONFIGS,
  type PipelineInput,
} from '@/lib/geo-v2'
import type {
  GEOv2GenerateResponse,
  PipelineProgress,
  GroundingSource,
  UniqueSellingPoint,
  FAQItem,
  CaseStudy,
  CaseStudyResult,
} from '@/types/geo-v2'
import type { ProductCategory, PlaybookSearchResult, PlaybookSection } from '@/types/playbook'

const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY })

// ==========================================
// V2 REQUEST/RESPONSE TYPES
// ==========================================

interface GEOv2GenerateRequest {
  productName: string
  youtubeUrl: string
  srtContent: string
  existingDescription?: string
  keywords: string[]
  productCategory?: ProductCategory | 'all'
  usePlaybook?: boolean
  launchDate?: string
  pipelineConfig?: 'full' | 'quick' | 'grounded'
  language?: 'ko' | 'en'
}

interface GroundingSignal {
  term: string
  score: number
  source?: string
  recency?: string
}

// ==========================================
// V2 RESPONSE SCHEMAS
// ==========================================

const descriptionSchema = {
  type: 'object',
  properties: {
    preview: {
      type: 'string',
      description: 'First 130 characters preview for search results',
    },
    full: {
      type: 'string',
      description: 'Full SEO-optimized description (300-500 characters)',
    },
    vanityLinks: {
      type: 'array',
      items: { type: 'string' },
      description: 'Suggested vanity links for call-to-action',
    },
  },
  required: ['preview', 'full', 'vanityLinks'],
}

const faqSchema = {
  type: 'object',
  properties: {
    faqs: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          question: { type: 'string' },
          answer: { type: 'string' },
          linkedUSPs: {
            type: 'array',
            items: { type: 'string' },
          },
        },
        required: ['question', 'answer'],
      },
      description: '5-7 FAQs addressing real user queries, linked to USPs',
    },
    queryPatternOptimization: {
      type: 'boolean',
      description: 'Whether FAQs are optimized for query patterns',
    },
  },
  required: ['faqs', 'queryPatternOptimization'],
}

const caseStudySchema = {
  type: 'object',
  properties: {
    caseStudies: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          title: { type: 'string' },
          scenario: { type: 'string' },
          solution: { type: 'string' },
          linkedUSPs: {
            type: 'array',
            items: { type: 'string' },
          },
          evidence: {
            type: 'object',
            properties: {
              type: { type: 'string' },
              confidence: { type: 'string' },
            },
          },
        },
        required: ['title', 'scenario', 'solution'],
      },
    },
  },
  required: ['caseStudies'],
}

const chaptersSchema = {
  type: 'object',
  properties: {
    timestamps: {
      type: 'string',
      description: 'Video timestamps (format: "0:00 Section name")',
    },
    autoGenerated: {
      type: 'boolean',
      description: 'Whether chapters were auto-generated from SRT',
    },
  },
  required: ['timestamps', 'autoGenerated'],
}

const keywordsSchema = {
  type: 'object',
  properties: {
    product: {
      type: 'array',
      items: { type: 'string' },
      description: 'Product-specific keywords',
    },
    generic: {
      type: 'array',
      items: { type: 'string' },
      description: 'Generic category keywords',
    },
    densityScore: {
      type: 'number',
      description: 'Keyword density score 0-100',
    },
  },
  required: ['product', 'generic', 'densityScore'],
}

// ==========================================
// MAIN API HANDLER
// ==========================================

export async function POST(request: NextRequest) {
  const startTime = Date.now()

  try {
    const body: GEOv2GenerateRequest = await request.json()
    const {
      productName,
      youtubeUrl,
      srtContent,
      existingDescription,
      keywords,
      productCategory,
      usePlaybook = true,
      launchDate,
      pipelineConfig = 'full',
      language = 'ko',
    } = body

    // Validation
    if (!productName || !srtContent) {
      return NextResponse.json(
        { error: 'Product name and SRT content are required' },
        { status: 400 }
      )
    }

    console.log(`[GEO v2] Starting pipeline: ${pipelineConfig}`)
    console.log(`[GEO v2] Product: ${productName}, Keywords: ${keywords.length}`)

    // ==========================================
    // STAGE 0: PARALLEL DATA FETCHING
    // ==========================================
    const [groundingSignals, playbookContext] = await Promise.all([
      fetchGroundingSignals(productName, keywords, launchDate),
      (usePlaybook && isPineconeConfigured())
        ? fetchPlaybookContext(productName, keywords, productCategory)
        : Promise.resolve([]),
    ])

    console.log(`[GEO v2] Data fetched in ${Date.now() - startTime}ms`)
    console.log(`[GEO v2] Grounding signals: ${groundingSignals.length}, Playbook chunks: ${playbookContext.length}`)

    if (!process.env.GEMINI_API_KEY) {
      return NextResponse.json(getMockV2Response(productName, keywords))
    }

    // ==========================================
    // STAGE 1: DESCRIPTION GENERATION WITH GROUNDING
    // ==========================================
    const descriptionResult = await generateDescription(
      productName,
      srtContent,
      existingDescription,
      keywords,
      groundingSignals,
      playbookContext,
      language
    )

    // Extract grounding sources from description generation
    const descriptionGroundingSources = extractSourcesFromGrounding(descriptionResult.groundingChunks)

    console.log(`[GEO v2] Description generated with ${descriptionGroundingSources.length} sources`)

    // ==========================================
    // STAGE 1.5: USP EXTRACTION
    // ==========================================
    const uspResult = await extractUSPs({
      productName,
      srtContent,
      keywords,
      groundingSignals,
      groundingSources: descriptionGroundingSources,
    })

    console.log(`[GEO v2] USPs extracted: ${uspResult.usps.length}, Method: ${uspResult.extractionMethod}`)

    // ==========================================
    // STAGE 2 & 3: PARALLEL - CHAPTERS + FAQ
    // ==========================================
    const [chaptersResult, faqResult] = await Promise.all([
      generateChapters(srtContent, productName),
      generateFAQ(productName, srtContent, uspResult.usps, groundingSignals, language),
    ])

    console.log(`[GEO v2] Chapters: ${chaptersResult.timestamps.split('\n').length} entries`)
    console.log(`[GEO v2] FAQs: ${faqResult.faqs.length} Q&As`)

    // ==========================================
    // STAGE 4 & 5: PARALLEL - STEP-BY-STEP + CASE STUDIES
    // ==========================================
    const isTutorialContent = detectTutorialContent(srtContent)

    const [stepByStepResult, caseStudiesResult] = await Promise.all([
      isTutorialContent
        ? generateStepByStep(srtContent, productName, language)
        : Promise.resolve(null),
      generateCaseStudies(productName, uspResult.usps, groundingSignals, language),
    ])

    if (stepByStepResult) {
      console.log(`[GEO v2] Step-by-step: ${stepByStepResult.steps.length} steps`)
    }
    console.log(`[GEO v2] Case studies: ${caseStudiesResult.caseStudies.length} cases`)

    // ==========================================
    // STAGE 6: KEYWORDS EXTRACTION
    // ==========================================
    const keywordsResult = await generateKeywords(
      productName,
      srtContent,
      keywords,
      groundingSignals,
      language
    )

    const hashtags = generateHashtags(productName, keywordsResult, keywords)

    console.log(`[GEO v2] Keywords: ${keywordsResult.product.length + keywordsResult.generic.length}`)
    console.log(`[GEO v2] Hashtags: ${hashtags.length}`)

    // ==========================================
    // STAGE 7: GROUNDING AGGREGATION
    // ==========================================
    const stageGroundingData = [
      {
        stage: 'description',
        sources: descriptionGroundingSources,
        searchQueries: groundingSignals.map(s => s.term),
      },
      {
        stage: 'usp_extraction',
        sources: extractUSPSources(uspResult.usps),
        searchQueries: [],
      },
      {
        stage: 'faq',
        sources: extractFAQSources(faqResult.faqs),
        searchQueries: [],
      },
      {
        stage: 'case_studies',
        sources: extractCaseStudySources(caseStudiesResult.caseStudies),
        searchQueries: [],
      },
    ]

    const groundingMetadata = aggregateGroundingMetadata(stageGroundingData)

    // ==========================================
    // FINAL SCORE CALCULATION
    // ==========================================
    const groundingQuality = calculateGroundingQualityScore({
      sources: groundingMetadata.sources,
      usps: uspResult.usps,
      totalSections: 7,
      sectionsWithGrounding: stageGroundingData.filter(s => s.sources.length > 0).length,
      contentLength: descriptionResult.description.full.length + faqResult.faqs.reduce((acc, f) => acc + f.answer.length, 0),
      citedContentLength: groundingMetadata.totalCitations * 200,
    })

    // Calculate component scores
    const keywordDensityScore = Math.min(15, Math.round(keywordsResult.densityScore / 100 * 15))
    const aiExposureScore = Math.min(25, Math.round((uspResult.groundingQuality / 100) * 25))
    const questionPatternsScore = Math.min(20, Math.round((faqResult.faqs.length / 7) * 20))
    const sentenceStructureScore = 12 // Would be calculated from actual content analysis
    const lengthComplianceScore = calculateLengthComplianceScore(descriptionResult.description.full)

    const finalScore = {
      keywordDensity: keywordDensityScore,
      aiExposure: aiExposureScore,
      questionPatterns: questionPatternsScore,
      sentenceStructure: sentenceStructureScore,
      lengthCompliance: lengthComplianceScore,
      groundingQuality,
      total: Math.round(
        (keywordDensityScore + aiExposureScore + questionPatternsScore +
          sentenceStructureScore + lengthComplianceScore + groundingQuality.total) * 100
      ) / 100,
    }

    console.log(`[GEO v2] Final score: ${finalScore.total}/100`)
    console.log(`[GEO v2] Pipeline completed in ${Date.now() - startTime}ms`)

    // ==========================================
    // BUILD RESPONSE
    // ==========================================
    const response: GEOv2GenerateResponse = {
      description: descriptionResult.description,
      uspResult,
      chapters: chaptersResult,
      faq: faqResult,
      stepByStep: stepByStepResult || undefined,
      caseStudies: caseStudiesResult,
      keywords: keywordsResult,
      hashtags,
      finalScore,
      groundingMetadata,
      progress: [],
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('[GEO v2] Pipeline error:', error)
    return NextResponse.json(
      { error: 'Failed to generate v2 content', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    )
  }
}

// ==========================================
// STAGE IMPLEMENTATIONS
// ==========================================

/**
 * Stage 1: Generate Description with Google Grounding
 */
async function generateDescription(
  productName: string,
  srtContent: string,
  existingDescription: string | undefined,
  keywords: string[],
  groundingSignals: GroundingSignal[],
  playbookContext: PlaybookSearchResult[],
  language: 'ko' | 'en'
): Promise<{
  description: { preview: string; full: string; vanityLinks: string[] }
  groundingChunks: Array<{ web?: { uri: string; title: string } }>
}> {
  const antiFabPrompt = getAntiFabricationPrompt('high')

  const systemInstruction = `You are a Samsung GEO (Generative Engine Optimization) specialist v2.
${antiFabPrompt}

## YOUR MISSION
Create an SEO-optimized video description that is:
1. Truthful and grounded in verifiable facts
2. Optimized for AI search engines (ChatGPT, Perplexity, Google AI Overview)
3. Following Samsung brand guidelines
4. Naturally integrating keywords

## BRAND GUIDELINES
${playbookContext.map(ctx => ctx.content).join('\n\n').slice(0, 2000)}

## OUTPUT REQUIREMENTS
- Preview: First 130 characters that appear in search results
- Full: Complete description 300-500 characters
- vanityLinks: 2-3 suggested short URLs

Output in ${language === 'ko' ? 'Korean' : 'English'}.`

  const userPrompt = `Generate optimized description for ${productName}:

## VIDEO TRANSCRIPT
${srtContent.slice(0, 3000)}

## EXISTING DESCRIPTION (if any)
${existingDescription || 'None provided'}

## TARGET KEYWORDS
${keywords.join(', ')}

## USER INTENT SIGNALS
${groundingSignals.slice(0, 5).map(s => `- ${s.term} (${s.score}%)`).join('\n')}`

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: userPrompt,
      config: {
        systemInstruction,
        responseMimeType: 'application/json',
        responseJsonSchema: descriptionSchema,
        temperature: 0.7,
        maxOutputTokens: 1500,
        // Enable Google Search grounding
        tools: [{ googleSearch: {} }],
      },
    })

    const content = response.text
    if (!content) throw new Error('No description generated')

    const parsed = JSON.parse(content)

    // Sanitize for fabrications
    const sanitized = sanitizeContent(parsed.full)
    if (sanitized.wasModified) {
      console.log(`[Description] Sanitized ${sanitized.modifications.length} potential fabrications`)
    }

    // Extract grounding chunks from response
    const groundingChunks = (response as unknown as {
      candidates?: Array<{
        groundingMetadata?: {
          groundingChunks?: Array<{ web?: { uri: string; title: string } }>
        }
      }>
    }).candidates?.[0]?.groundingMetadata?.groundingChunks || []

    return {
      description: {
        preview: parsed.preview || sanitized.sanitized.slice(0, 130),
        full: sanitized.sanitized,
        vanityLinks: parsed.vanityLinks || [],
      },
      groundingChunks,
    }
  } catch (error) {
    console.error('[Description] Generation failed:', error)
    return {
      description: {
        preview: `${productName}의 모든 것을 알아보세요.`,
        full: `${productName}의 주요 기능과 특징을 소개합니다. ${keywords.slice(0, 3).join(', ')} 등 다양한 기능을 확인해보세요.`,
        vanityLinks: [`samsung.com/${productName.toLowerCase().replace(/\s+/g, '-')}`],
      },
      groundingChunks: [],
    }
  }
}

/**
 * Stage 2: Generate Chapters
 */
async function generateChapters(
  srtContent: string,
  productName: string
): Promise<{ timestamps: string; autoGenerated: boolean }> {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: `Generate video timestamps from this SRT content for ${productName}:

${srtContent.slice(0, 4000)}

Format: "0:00 Section Name" (one per line)
Create 5-10 meaningful chapter markers based on content transitions.`,
      config: {
        responseMimeType: 'application/json',
        responseJsonSchema: chaptersSchema,
        temperature: 0.5,
        maxOutputTokens: 800,
      },
    })

    const content = response.text
    if (!content) throw new Error('No chapters generated')

    const parsed = JSON.parse(content)
    return {
      timestamps: parsed.timestamps || '',
      autoGenerated: true,
    }
  } catch (error) {
    console.error('[Chapters] Generation failed:', error)
    return {
      timestamps: `0:00 ${productName} 소개\n0:30 주요 기능\n1:00 상세 리뷰\n2:00 총평`,
      autoGenerated: true,
    }
  }
}

/**
 * Stage 3: Generate FAQ with USP Linking
 */
async function generateFAQ(
  productName: string,
  srtContent: string,
  usps: UniqueSellingPoint[],
  groundingSignals: GroundingSignal[],
  language: 'ko' | 'en'
): Promise<{ faqs: FAQItem[]; queryPatternOptimization: boolean }> {
  const antiFabPrompt = getAntiFabricationPrompt('medium')

  const uspContext = usps.map((usp, i) =>
    `USP ${i + 1}: ${usp.feature} - ${usp.differentiation}`
  ).join('\n')

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: `Generate FAQ for ${productName}:

${antiFabPrompt}

## UNIQUE SELLING POINTS TO ADDRESS
${uspContext}

## USER SEARCH SIGNALS
${groundingSignals.slice(0, 5).map(s => `- ${s.term}`).join('\n')}

## VIDEO CONTENT
${srtContent.slice(0, 2000)}

Create 5-7 Q&A pairs that:
1. Address real user queries based on signals
2. Link answers to specific USPs where relevant
3. Use natural conversational language
4. Are optimized for AI search engines

Output in ${language === 'ko' ? 'Korean' : 'English'}.`,
      config: {
        responseMimeType: 'application/json',
        responseJsonSchema: faqSchema,
        temperature: 0.7,
        maxOutputTokens: 2000,
        tools: [{ googleSearch: {} }],
      },
    })

    const content = response.text
    if (!content) throw new Error('No FAQ generated')

    const parsed = JSON.parse(content)
    return {
      faqs: parsed.faqs || [],
      queryPatternOptimization: true,
    }
  } catch (error) {
    console.error('[FAQ] Generation failed:', error)
    return {
      faqs: [
        {
          question: `${productName}의 가장 큰 특징은 무엇인가요?`,
          answer: usps[0]?.differentiation || '최신 기술을 탑재한 프리미엄 제품입니다.',
          linkedUSPs: usps[0] ? [usps[0].feature] : [],
          confidence: 'medium',
        },
      ],
      queryPatternOptimization: false,
    }
  }
}

/**
 * Stage 4: Generate Step-by-Step (for tutorial content)
 */
async function generateStepByStep(
  srtContent: string,
  productName: string,
  language: 'ko' | 'en'
): Promise<{ steps: string[]; isTutorialContent: boolean }> {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: `Extract step-by-step instructions from this tutorial content for ${productName}:

${srtContent.slice(0, 3000)}

Create clear, actionable steps in ${language === 'ko' ? 'Korean' : 'English'}.
Format as a JSON array of strings.`,
      config: {
        responseMimeType: 'application/json',
        responseJsonSchema: {
          type: 'object',
          properties: {
            steps: {
              type: 'array',
              items: { type: 'string' },
            },
          },
          required: ['steps'],
        },
        temperature: 0.5,
        maxOutputTokens: 1000,
      },
    })

    const content = response.text
    if (!content) throw new Error('No steps generated')

    const parsed = JSON.parse(content)
    return {
      steps: parsed.steps || [],
      isTutorialContent: true,
    }
  } catch (error) {
    console.error('[Step-by-step] Generation failed:', error)
    return { steps: [], isTutorialContent: false }
  }
}

/**
 * Stage 5: Generate Case Studies
 */
async function generateCaseStudies(
  productName: string,
  usps: UniqueSellingPoint[],
  groundingSignals: GroundingSignal[],
  language: 'ko' | 'en'
): Promise<CaseStudyResult> {
  const antiFabPrompt = getAntiFabricationPrompt('high')

  const uspContext = usps.slice(0, 3).map((usp, i) =>
    `USP ${i + 1}: ${usp.feature}\n  - Benefit: ${usp.userBenefit}\n  - Confidence: ${usp.confidence}`
  ).join('\n\n')

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: `Generate realistic case studies for ${productName}:

${antiFabPrompt}

## USPs TO DEMONSTRATE
${uspContext}

## USER INTEREST SIGNALS
${groundingSignals.slice(0, 3).map(s => `- ${s.term}`).join('\n')}

Create 2-3 realistic use case scenarios that:
1. Demonstrate specific USP benefits
2. Are relatable to target users
3. Include realistic (but not fabricated) outcomes
4. Use hedging language for claims without verification

Output in ${language === 'ko' ? 'Korean' : 'English'}.`,
      config: {
        responseMimeType: 'application/json',
        responseJsonSchema: caseStudySchema,
        temperature: 0.7,
        maxOutputTokens: 1500,
        tools: [{ googleSearch: {} }],
      },
    })

    const content = response.text
    if (!content) throw new Error('No case studies generated')

    const parsed = JSON.parse(content)
    return {
      caseStudies: parsed.caseStudies || [],
      extractionMethod: 'grounded',
    }
  } catch (error) {
    console.error('[Case Studies] Generation failed:', error)
    return { caseStudies: [], extractionMethod: 'generative' }
  }
}

/**
 * Stage 6: Generate Keywords
 */
async function generateKeywords(
  productName: string,
  srtContent: string,
  inputKeywords: string[],
  groundingSignals: GroundingSignal[],
  language: 'ko' | 'en'
): Promise<{ product: string[]; generic: string[]; densityScore: number }> {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: `Extract and categorize keywords for ${productName}:

## TRANSCRIPT
${srtContent.slice(0, 2000)}

## USER INPUT KEYWORDS
${inputKeywords.join(', ')}

## TRENDING SIGNALS
${groundingSignals.slice(0, 5).map(s => s.term).join(', ')}

Categorize into:
1. Product-specific: Brand, model, feature names
2. Generic: Category terms, use cases, benefits

Output in ${language === 'ko' ? 'Korean' : 'English'}.`,
      config: {
        responseMimeType: 'application/json',
        responseJsonSchema: keywordsSchema,
        temperature: 0.5,
        maxOutputTokens: 800,
      },
    })

    const content = response.text
    if (!content) throw new Error('No keywords generated')

    const parsed = JSON.parse(content)
    return {
      product: parsed.product || [],
      generic: parsed.generic || [],
      densityScore: parsed.densityScore || 50,
    }
  } catch (error) {
    console.error('[Keywords] Generation failed:', error)
    return {
      product: [productName, 'Samsung', 'Galaxy'],
      generic: inputKeywords,
      densityScore: 50,
    }
  }
}

// ==========================================
// HELPER FUNCTIONS
// ==========================================

/**
 * Fetch grounding signals from Perplexity
 */
async function fetchGroundingSignals(
  productName: string,
  keywords: string[],
  launchDate?: string
): Promise<GroundingSignal[]> {
  try {
    const apiKey = process.env.PERPLEXITY_API_KEY
    if (!apiKey) {
      console.warn('[Grounding] No Perplexity API key')
      return generateFallbackSignals(productName, keywords)
    }

    const queries = [
      `${productName} reviews 2024 2025`,
      `${productName} features specifications`,
      `${productName} ${keywords[0] || 'camera'} performance`,
    ]

    const results = await Promise.all(
      queries.map(query =>
        fetch('https://api.perplexity.ai/search', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            query,
            max_results: 5,
            max_tokens_per_page: 512,
          }),
        })
          .then(r => r.ok ? r.json() : { results: [] })
          .then(d => d.results || [])
          .catch(() => [])
      )
    )

    const allResults = results.flat()
    return extractSignalsFromResults(allResults, keywords)
  } catch (error) {
    console.error('[Grounding] Failed:', error)
    return generateFallbackSignals(productName, keywords)
  }
}

/**
 * Extract signals from search results
 */
function extractSignalsFromResults(
  results: Array<{ title?: string; snippet?: string; url?: string; date?: string }>,
  userKeywords: string[]
): GroundingSignal[] {
  const signalMap = new Map<string, { count: number; sources: string[]; recency?: string }>()

  const intentPatterns = [
    'camera', 'battery', 'display', 'performance', 'AI', 'Galaxy AI',
    'design', 'charging', 'storage', 'price', 'comparison', 'review',
    '카메라', '배터리', '디스플레이', '성능', '가격', '디자인',
  ]

  for (const result of results) {
    const text = `${result.title || ''} ${result.snippet || ''}`.toLowerCase()

    for (const pattern of intentPatterns) {
      if (text.includes(pattern.toLowerCase())) {
        const existing = signalMap.get(pattern) || { count: 0, sources: [] }
        existing.count++
        if (result.url) existing.sources.push(result.url)
        if (result.date && !existing.recency) existing.recency = result.date
        signalMap.set(pattern, existing)
      }
    }

    for (const keyword of userKeywords) {
      if (text.includes(keyword.toLowerCase())) {
        const existing = signalMap.get(keyword) || { count: 0, sources: [] }
        existing.count += 2
        signalMap.set(keyword, existing)
      }
    }
  }

  const maxCount = Math.max(...Array.from(signalMap.values()).map(v => v.count), 1)

  return Array.from(signalMap.entries())
    .map(([term, data]) => ({
      term,
      score: Math.round((data.count / maxCount) * 100),
      source: data.sources[0],
      recency: data.recency,
    }))
    .sort((a, b) => b.score - a.score)
    .slice(0, 15)
}

/**
 * Generate fallback signals when API unavailable
 */
function generateFallbackSignals(productName: string, keywords: string[]): GroundingSignal[] {
  const defaultSignals = ['camera', 'battery', 'display', 'performance', 'AI', 'design']
  return [...keywords, ...defaultSignals].slice(0, 10).map((term, i) => ({
    term,
    score: 100 - i * 10,
  }))
}

/**
 * Fetch playbook context
 */
async function fetchPlaybookContext(
  productName: string,
  keywords: string[],
  productCategory?: ProductCategory | 'all'
): Promise<PlaybookSearchResult[]> {
  try {
    const queries = [
      `Samsung brand guidelines ${productName}`,
      `GEO optimization AI search content`,
      `Samsung tone of voice writing style`,
      ...keywords.slice(0, 2).map(k => `Samsung ${k} marketing`),
    ]

    const ragContext = await multiQuerySearch(queries, {
      productCategory,
      topKPerQuery: 3,
      finalTopN: 8,
      deduplicateByContent: true,
    })

    return ragContext.results
  } catch (error) {
    console.error('[Playbook] Failed:', error)
    return []
  }
}

/**
 * Extract sources from grounding chunks
 */
function extractSourcesFromGrounding(
  chunks: Array<{ web?: { uri: string; title: string } }>
): GroundingSource[] {
  return extractGroundingSources(chunks)
}

/**
 * Extract sources from USPs
 */
function extractUSPSources(usps: UniqueSellingPoint[]): GroundingSource[] {
  const sources: GroundingSource[] = []
  for (const usp of usps) {
    if (usp.evidence.sources) {
      for (const source of usp.evidence.sources) {
        if (source.startsWith('http')) {
          sources.push({
            uri: source,
            title: 'USP Evidence',
            usedIn: ['usp_extraction'],
            tier: getSourceTier(source),
          })
        }
      }
    }
  }
  return sources
}

/**
 * Extract sources from FAQs
 */
function extractFAQSources(faqs: FAQItem[]): GroundingSource[] {
  // FAQs may reference sources in answers - extract URLs
  const sources: GroundingSource[] = []
  const urlRegex = /https?:\/\/[^\s]+/g

  for (const faq of faqs) {
    const matches = faq.answer.match(urlRegex) || []
    for (const url of matches) {
      sources.push({
        uri: url,
        title: 'FAQ Reference',
        usedIn: ['faq'],
        tier: getSourceTier(url),
      })
    }
  }
  return sources
}

/**
 * Extract sources from case studies
 */
function extractCaseStudySources(caseStudies: CaseStudy[]): GroundingSource[] {
  const sources: GroundingSource[] = []
  const urlRegex = /https?:\/\/[^\s]+/g

  for (const study of caseStudies) {
    const text = `${study.scenario} ${study.solution}`
    const matches = text.match(urlRegex) || []
    for (const url of matches) {
      sources.push({
        uri: url,
        title: 'Case Study Reference',
        usedIn: ['case_studies'],
        tier: getSourceTier(url),
      })
    }
  }
  return sources
}

/**
 * Detect if content is tutorial/how-to
 */
function detectTutorialContent(srtContent: string): boolean {
  const tutorialIndicators = [
    '방법', 'how to', '단계', 'step', '따라', 'follow',
    '설정', 'setup', '사용법', 'guide', '튜토리얼', 'tutorial',
  ]

  const lowerContent = srtContent.toLowerCase()
  return tutorialIndicators.some(indicator =>
    lowerContent.includes(indicator.toLowerCase())
  )
}

/**
 * Calculate length compliance score
 */
function calculateLengthComplianceScore(description: string): number {
  const length = description.length
  if (length >= 300 && length <= 500) return 15
  if (length >= 250 && length <= 550) return 12
  if (length >= 200 && length <= 600) return 9
  if (length >= 150 && length <= 700) return 6
  return 3
}

/**
 * Generate hashtags
 */
function generateHashtags(
  productName: string,
  keywords: { product: string[]; generic: string[] },
  inputKeywords: string[]
): string[] {
  const brandTags = ['#Samsung', '#삼성', '#Galaxy', '#GalaxyAI']
  const productTags = [
    `#${productName.replace(/\s+/g, '')}`,
    ...keywords.product.slice(0, 3).map(k => `#${k.replace(/\s+/g, '')}`),
  ]
  const genericTags = [
    ...keywords.generic.slice(0, 3).map(k => `#${k.replace(/\s+/g, '')}`),
    ...inputKeywords.slice(0, 3).map(k => `#${k.replace(/\s+/g, '')}`),
  ]
  const commonTags = ['#테크리뷰', '#TechReview', '#스마트폰', '#언박싱']

  return [...new Set([...brandTags, ...productTags, ...genericTags, ...commonTags])].slice(0, 15)
}

/**
 * Mock response for development
 */
function getMockV2Response(productName: string, keywords: string[]): GEOv2GenerateResponse {
  return {
    description: {
      preview: `${productName}의 혁신적인 기능을 만나보세요!`,
      full: `${productName}의 주요 기능과 특징을 자세히 알아보세요. ${keywords.slice(0, 3).join(', ')} 등 다양한 기능을 확인할 수 있습니다. Galaxy AI와 함께하는 새로운 경험을 시작하세요.`,
      vanityLinks: [`samsung.com/${productName.toLowerCase().replace(/\s+/g, '-')}`],
    },
    uspResult: {
      usps: [],
      competitiveContext: '',
      extractionMethod: 'generative',
      groundingQuality: 0,
    },
    chapters: {
      timestamps: `0:00 인트로\n0:30 주요 기능\n1:00 상세 리뷰\n2:00 총평`,
      autoGenerated: true,
    },
    faq: {
      faqs: [],
      queryPatternOptimization: false,
    },
    keywords: {
      product: [productName, 'Samsung', 'Galaxy'],
      generic: keywords,
      densityScore: 50,
    },
    hashtags: ['#Samsung', `#${productName.replace(/\s+/g, '')}`, '#GalaxyAI'],
    finalScore: {
      keywordDensity: 10,
      aiExposure: 15,
      questionPatterns: 10,
      sentenceStructure: 10,
      lengthCompliance: 10,
      groundingQuality: {
        citationDensity: 0,
        sourceAuthority: 0,
        coverage: 0,
        total: 0,
        breakdown: {
          citationPercentage: 0,
          tier1Sources: 0,
          tier2Sources: 0,
          tier3Sources: 0,
          sectionsWithGrounding: 0,
          totalSections: 7,
        },
      },
      total: 55,
    },
    groundingMetadata: {
      webSearchQueries: [],
      sources: [],
      citationDensity: 0,
      totalCitations: 0,
      uniqueSources: 0,
    },
    progress: [],
  }
}
